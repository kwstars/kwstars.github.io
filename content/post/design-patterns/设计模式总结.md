---
title: "设计模式总结"
date: 2020-04-01T20:25:05+08:00
draft: true
tags: ["设计模式"]
categories: ["Go"]
---



## 设计原则
1. 找出程序中会变化的方面，然后将其和规定不变的方面相分离。
2. 针对接口编程，而不是针对实现编程。
3. 多用组合，少用继承。
4. 为了交互对象之间的松耦合设计而努力。-->观察者模式
5. 开放-关闭原则。类应该对扩展开放，对修改关闭。 -->装饰器模式
6. 依赖抽象，不要依赖具体实现

## 创建型: 解决对象的创建

### 01 单例模式（Singleton pattern）

确保一个类只有一个实例，并提供全局访问点。

### 02 工厂方法 （Factory Method pattern）

定义了一个创建对象的接口，但由于类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

### 03 抽象工厂 (Abstract Factory）

提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

### 04 构造器 （Builder Pattern）

建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。

### 05 原型 （Prototype pattern 不常用）

## 结构型: 解决类或对象的组合或组装

### 06 代理模式（Proxy）

代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。

### 07 桥接模式（Bridge）

桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。

### 08 装饰者模式（Decorator）
动态的将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。

装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。

### 09 适配器模式（Adapter）

适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。

### 10 外观模式（Facade 不常用）

### 11 组合模式（Composite 不常用）

### 12 享元模式（Flyweight 不常用）

## 行为型: 解决类或对象之间的交互

### [13 观察者模式（Observer）]({{< ref "" >}})

在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。

**设计原则**
1. 找出程序中会变化的方面，然后将其和规定不变的方面相分离。
> 在观察者模式中，会改变的是主题的状态，以及观察者的数目和类型。用这个模式，你可以改变依赖于主题状态的对象，却不必改变主题。这就叫提前规划。
2. 针对接口编程，而不是针对实现编程。
 > 主题与观察者都使用接口：观察者利用主题的接口想主题注册，而主题利观察者接口通知观察者。这样可以让两者之间运作正常。又同时具有松耦合的优点。
3. 多用组合，少用继承。
> 观察者模式利用“组合”将许多观察者组合进主题中。对象之间的这种关系不是通过继承产生的，而是在运行是利用组合的方式而产生的。

### 14 模板模式（Template Method）

### 15 策略模式（Strategy）
定义了算法族，分别分装起来，让它们之间可以相互替换，此模式让算法的变化独立与使用算法的客户。

### 16 职责链模式（Chain of Responsibility）

### 17 迭代器模式（Iterator）

### 18 状态模式（State）

### 19 访问者模式（Visitor 不常用）

### 20 备忘录模式（Memento 不常用）

### 21 命令模式（Command 不常用）
`当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式`

将请求封装成对象，这可以让你使用不同的请求、队列或日志请求来参数化其他对象。命令模式也可以支持撤销操作。

**要点**
1. 命令模式将发出请求的对象和执行请求的对象解耦
2. 在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接收者和一个或一组动作。
3. 调用者通过调用命令对象的execute()发出请求，这会使得接收者的动作被调用。
4. 调用者可以接受命令当作参数，甚至在运行时动态地进行。
5. 命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态。
6. 宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销。
7. 实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接收者。
8. 命令也可以用来实现日志和事物系统。

### 22 解释器模式（Interpreter 不常用）

### 23 中介模式（Mediator 不常用）

## Go中的设计模式

### 选项模式（Options）
