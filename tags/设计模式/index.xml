<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on Kira's blog</title><link>https://linux88.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on Kira's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 13 Mar 2020 20:25:05 +0800</lastBuildDate><atom:link href="https://linux88.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>设计模式--状态模式</title><link>https://linux88.com/post/design-patterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B/18%E7%8A%B6%E6%80%81/</link><pubDate>Fri, 13 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B/18%E7%8A%B6%E6%80%81/</guid><description>状态模式的概念 有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Tra</description></item><item><title>设计模式--观察者模式</title><link>https://linux88.com/post/design-patterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B/13%E8%A7%82%E5%AF%9F%E8%80%85/</link><pubDate>Fri, 13 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B/13%E8%A7%82%E5%AF%9F%E8%80%85/</guid><description>观察者模式的概念 什么是观察者模式 在对象间定义一种一对多的依赖关系，当这个对象状态发生改变时，所有依赖它的对象都会被通知并自动更新。 Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically. /' OBSERVER '/ @startuml interface Subject { + attach(in o : Observer) + detach(in o</description></item><item><title>设计模式--享元模式</title><link>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/12%E4%BA%AB%E5%85%83/</link><pubDate>Thu, 12 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/12%E4%BA%AB%E5%85%83/</guid><description>享元模式的概念 什么是享元模式 使用共享对象可有效地支持大量的细粒度的对象。指享元模式要求能够共享的对象必须是轻量级对象，也就是细粒度对象，因此享元模式又称为轻量级模式。 Use sharing to support large numbers of fine-grained objects efficiently. 内部状态 (Intrinsic St</description></item><item><title>设计模式--外观模式</title><link>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/10%E5%A4%96%E8%A7%82/</link><pubDate>Tue, 10 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/10%E5%A4%96%E8%A7%82/</guid><description>外观模式的概念 什么是外观模式 门面模式（Facade Pattern）也叫做外观模式，是一种比较常用的封装模式，其定义如下：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高</description></item><item><title>设计模式--适配器模式</title><link>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/09%E9%80%82%E9%85%8D%E5%99%A8/</link><pubDate>Mon, 09 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/09%E9%80%82%E9%85%8D%E5%99%A8/</guid><description>适配器模式的概念 什么是适配器模式 将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。 适配模式的作用： 接口转换，将原有的接口（或方法）转换成另一种接口</description></item><item><title>设计模式--装饰器模式</title><link>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/08%E8%A3%85%E9%A5%B0%E5%99%A8/</link><pubDate>Sun, 08 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/08%E8%A3%85%E9%A5%B0%E5%99%A8/</guid><description>装饰器模式的概念 什么是装饰器模式 动态地给一个对象增加一些额外的职责，就拓展对象功能来说，装饰模式比生成子类的方式更为灵活。 Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. /' DECORATOR '/ @startuml interface Component { + operation() } class ConcreteComponent { + operation() } interface Decorator { component Component +</description></item><item><title>设计模式--桥接模式</title><link>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/07%E6%A1%A5%E6%8E%A5/</link><pubDate>Sat, 07 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/07%E6%A1%A5%E6%8E%A5/</guid><description>桥接模式的概念 什么是桥接模式 桥接模式被定义为：“将抽象和实现解耦，让它们可以独立变化。”在其他资料和书籍中，还有另外一种更加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式</description></item><item><title>设计模式--代理模式</title><link>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/06%E4%BB%A3%E7%90%86/</link><pubDate>Fri, 06 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/06%E4%BB%A3%E7%90%86/</guid><description>代理模式的概念 什么是代理模式 为其他对象提供一种代理以控制对这个对象的访问。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。 Provide a surrogate or placeholder for another object to control access to it. /' PROXY '/ @startuml class Client interface Subject { +</description></item><item><title>设计模式--原型模式</title><link>https://linux88.com/post/design-patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/05%E5%8E%9F%E5%9E%8B/</link><pubDate>Thu, 05 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/05%E5%8E%9F%E5%9E%8B/</guid><description>原型模式的概念 什么是原型模式 用原型实例指定要创建对象的种类，并通过拷贝这些原型的属性来创建新的对象。 Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype. /' PROTOTYPE '/ @startuml interface Prototype { + clone() } class Client class ConcretePrototype1 { + clone() } class ConcretePrototype2 { + clone() } hide empty members Client --&amp;gt; Prototype Prototype &amp;lt;|--</description></item><item><title>设计模式--建造者</title><link>https://linux88.com/post/design-patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/04%E5%BB%BA%E9%80%A0%E8%80%85/</link><pubDate>Wed, 04 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/04%E5%BB%BA%E9%80%A0%E8%80%85/</guid><description>建造者的概念 什么是建造者模式 将一复杂对象的构建过程和它的表现分离，使得同样的构建过程可以获取（创建）不同的表现。 Separate the construction of a complex object from its representation so that the same construction process can create different representation. /' BUILDER '/ @startuml class Director { + construct() } interface Builder { buildPart() } class ConcreteBuilder { + buildPart() + getResult() } class</description></item></channel></rss>