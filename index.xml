<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kira's blog</title><link>https://blog.linux88.com/</link><description>Recent content on Kira's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 Sep 2021 14:44:15 +0800</lastBuildDate><atom:link href="https://blog.linux88.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Testing With Gomock</title><link>https://blog.linux88.com/post/Go/testing-with-gomock/</link><pubDate>Wed, 01 Sep 2021 14:44:15 +0800</pubDate><guid>https://blog.linux88.com/post/Go/testing-with-gomock/</guid><description/></item><item><title>Embed</title><link>https://blog.linux88.com/post/Go/embed/</link><pubDate>Thu, 15 Jul 2021 09:24:10 +0800</pubDate><guid>https://blog.linux88.com/post/Go/embed/</guid><description/></item><item><title>Kafka命令</title><link>https://blog.linux88.com/post/OPS/kafka%E5%91%BD%E4%BB%A4/</link><pubDate>Tue, 13 Jul 2021 09:41:26 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/kafka%E5%91%BD%E4%BB%A4/</guid><description>Topic 创建 和修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 创建一个名为 adb-test，分区为20, 分区副本为3 topic kafka-topics --create --topic adb-test --partitions 20 --replication-factor 3 --bootstrap-server localhost:19091 # 创建topic kafka-topics --create --topic my_topic_name --partitions 20 --replication-factor 3 --config x=y --bootstrap-server localhost:9092 # 修改 partitions 为40 kafka-topics --alter --topic my_topic_name --partitions 40 --bootstrap-server localhost:9092 # 添加配置 kafka-configs</description></item><item><title>Kafka参数</title><link>https://blog.linux88.com/post/OPS/kafka%E5%8F%82%E6%95%B0/</link><pubDate>Tue, 13 Jul 2021 09:12:20 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/kafka%E5%8F%82%E6%95%B0/</guid><description>Broker 端参数 log.dirs 指定了 Broker 需要使用的若干个文件目录路径。 /home/kafka1,/home/kafka2,/home/kafka3 zookeeper.connect kafka链接zk的参数 1 2 3 4 5 6 # 单kafka使用zk zk1:2181,zk2:2181,zk3:2181 # 多kafka使用zk zk1:2181,zk2:2181,zk3:2181/kafka1 zk1:2181,zk2:2181,zk3:2181/kafka2 listeners 告诉外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务</description></item><item><title>Contexts and structs</title><link>https://blog.linux88.com/post/Go/Contexts-and-structs/</link><pubDate>Sun, 11 Jul 2021 21:14:41 +0800</pubDate><guid>https://blog.linux88.com/post/Go/Contexts-and-structs/</guid><description>此文为 Contexts and structs 译文 介绍 在许多Go API中，尤其是现代的API，函数和方法的第一个参数往往是context.Context。Context 提供了一种跨API边界和进程之间传输超时、取消和传递元数据信息。当</description></item><item><title>Disable Transparent Huge Pages (THP)</title><link>https://blog.linux88.com/post/OPS/Disable_Transparent_Huge_Pages/</link><pubDate>Tue, 06 Jul 2021 12:25:37 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/Disable_Transparent_Huge_Pages/</guid><description>Disable Transparent Huge Pages (THP)</description></item><item><title>Garbage Collection Semantics</title><link>https://blog.linux88.com/post/Go/Garbage-Collection-Semantics/</link><pubDate>Mon, 07 Jun 2021 18:15:52 +0800</pubDate><guid>https://blog.linux88.com/post/Go/Garbage-Collection-Semantics/</guid><description>从1.12版本开始，go使用了一个非生成的、并发的、三色的、标记和清扫的收集器 Mark Setup 当一个垃圾收集开始时，必须执行的第一个活动是打开写屏障。 为了打开写屏障，每一个正在运行的应用程序的程序都必须停止。 在垃</description></item><item><title>Google Doc 几个小技巧</title><link>https://blog.linux88.com/post/OPS/Google-Doc-%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/</link><pubDate>Sat, 22 May 2021 21:59:52 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/Google-Doc-%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid><description>手写输入特殊字符 插入 -&amp;gt; 特殊字符 插入搜索链接 ctrl + k 会自动搜索豆瓣， gitbook的链接 添加脚注 ctrl + alt + f 点右下角探索，搜索后可以添加脚注 搜索图片后文字绕开 链接直接拖到文档 插件画图Mermaid Add-ons -&amp;gt; Mermaid 插件</description></item><item><title>Goland快捷键</title><link>https://blog.linux88.com/post/IDE/Goland%E5%BF%AB%E6%8D%B7%E9%94%AE/</link><pubDate>Thu, 01 Apr 2021 18:26:07 +0800</pubDate><guid>https://blog.linux88.com/post/IDE/Goland%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid><description>Editor Actions Goland(Windows) Move Caret to Code Block End(将插入符移动到代码块末端) Ctrl+] Move Caret to Code Block End With Selection(选择并将插入符移动到代码块末尾) Ctrl+Shift+] Move Caret to Code Block Start Ctrl+[ Move Caret to Code Block Start With Selection Ctrl+Shift+[ Complete Current Statement(完成当前行) Ctrl+Shift+Enter Delete Line Ctrl+Y Delete to</description></item><item><title>Unsafe</title><link>https://blog.linux88.com/post/Go/unsafe/</link><pubDate>Wed, 31 Mar 2021 14:42:09 +0800</pubDate><guid>https://blog.linux88.com/post/Go/unsafe/</guid><description>Type-Unsafe Pointers 深度解密Go语言之unsafe</description></item><item><title>使用Viper访问嵌套配置</title><link>https://blog.linux88.com/post/Go/viper/</link><pubDate>Sun, 28 Mar 2021 10:56:06 +0800</pubDate><guid>https://blog.linux88.com/post/Go/viper/</guid><description>本文翻译自《Accessing Nested Config with Viper》。全文如下： 我在写一个Go程序，它把其他一些东西粘在一起，所以它有一大堆基本上不相干的配置，被倾倒在一个yaml文件中。我对Viper的这种非标准使用有</description></item><item><title>如何在Go中处理JSON数据</title><link>https://blog.linux88.com/post/Go/%E5%A6%82%E4%BD%95%E5%9C%A8Go%E4%B8%AD%E5%A4%84%E7%90%86JSON%E6%95%B0%E6%8D%AE/</link><pubDate>Thu, 25 Mar 2021 12:04:45 +0800</pubDate><guid>https://blog.linux88.com/post/Go/%E5%A6%82%E4%BD%95%E5%9C%A8Go%E4%B8%AD%E5%A4%84%E7%90%86JSON%E6%95%B0%E6%8D%AE/</guid><description>Tutorial: How to work with JSON data in Go You might not be using json.Decoder correctly in golang</description></item><item><title>GCE 和 Github Action</title><link>https://blog.linux88.com/post/GCP/GCE%E5%92%8CGithubAction/</link><pubDate>Sun, 21 Mar 2021 10:34:27 +0800</pubDate><guid>https://blog.linux88.com/post/GCP/GCE%E5%92%8CGithubAction/</guid><description>通过 Github Action 部署应用, 此方法可能有些权限问题。 一、进入GCP的 IAM &amp;amp; Admin 1.1 在Service Accounts中创建一个用于github action的帐号 1.2 将github帐号添加到默认的xxxxxxxxxx-co</description></item><item><title>Goroutine并发控制</title><link>https://blog.linux88.com/post/Go/goroutine%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link><pubDate>Fri, 15 Jan 2021 20:57:51 +0800</pubDate><guid>https://blog.linux88.com/post/Go/goroutine%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid><description>此文为 Optimization for Number of goroutines Using Feedback Control 译文 Concurrency and complexity Concurrency and Go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { var wg sync.WaitGroup sem := make(chan struct{}, 3) for i := 0; i &amp;lt; 10; i++ { wg.Add(1) sem &amp;lt;- struct{}{} go func() { defer wg.DonOptimization for Number of goroutines Using Feedback Controle() defer func() { &amp;lt;-sem }() task() }() } wg.Wait() close(sem) } 1 Concurrency and application 为了实现速度和稳定性，并发数</description></item><item><title>Go Build Flags</title><link>https://blog.linux88.com/post/Go/flags/</link><pubDate>Wed, 13 Jan 2021 15:13:52 +0800</pubDate><guid>https://blog.linux88.com/post/Go/flags/</guid><description>在构建时设置一个环境变量 一个非常方便的构建标志，允许你在构建时从命令行设置一个变量。看下面的例子。 1 2 3 4 5 6 7 8 9 10 11 package main import ( &amp;#34;fmt&amp;#34; ) var who string func main() { fmt.Printf(&amp;#34;Hello, %s\n&amp;#34;, who) } 使用默认值我们得到以下结果。 1 2 3 4 $ go run main.go Hello, 通</description></item><item><title>Slice Tricks</title><link>https://blog.linux88.com/post/Go/slice%E6%80%A7%E8%83%BD/</link><pubDate>Tue, 12 Jan 2021 18:26:42 +0800</pubDate><guid>https://blog.linux88.com/post/Go/slice%E6%80%A7%E8%83%BD/</guid><description>Slice Tricks Slice Tricks的图 Append 1 a = append(a, b...) Copy 1 2 3 4 5 6 b = make([]T, len(a)) copy(b, a) // 这两种方法往往比上面的方法慢一些，但如果复制后有更多的元素要附加到b上，效率会更高。 b = append([]T(nil), a...) b = append(a[:0:0], a...) Cut 1 a = append(a[:i], a[j:]...) Delete 1 2 3 a = append(a[:i], a[i+1:]...) // or a = a[:i+copy(a[i:],</description></item><item><title>HTTP3(基于QUIC的HTTP)如何工作？UDP的优点，版本之间的差异(v1.0/v1.1/v2/v3)</title><link>https://blog.linux88.com/post/HTTP/HTTP3%E5%9F%BA%E4%BA%8EQUIC%E7%9A%84HTTP%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9CUDP%E7%9A%84%E4%BC%98%E7%82%B9%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82v1.0-v1.1-v2-v3/</link><pubDate>Sun, 13 Dec 2020 19:53:26 +0800</pubDate><guid>https://blog.linux88.com/post/HTTP/HTTP3%E5%9F%BA%E4%BA%8EQUIC%E7%9A%84HTTP%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9CUDP%E7%9A%84%E4%BC%98%E7%82%B9%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82v1.0-v1.1-v2-v3/</guid><description>本文翻译自《How does HTTP/3 (HTTP over QUIC) work?〜Advantages of UDP, differences between versions(v1.0/v1.1/v2/v3)〜》。全文如下： HTTP协议为互联网的传播做出了贡献。而现在，其新版本HTTP/3</description></item><item><title>MicroK8s</title><link>https://blog.linux88.com/post/OPS/MicroK8s/</link><pubDate>Wed, 18 Nov 2020 09:46:33 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/MicroK8s/</guid><description>一、安装MicroK8s 1.1 安装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 安装MicroK8s sudo snap install microk8s --classic --channel=1.19 # 查所有MicroK8s的版本 snap info microk8s # 加入用户组并对会话刷新 sudo usermod -a -G microk8s $USER sudo chown -f -R $USER ~/.kube su - $USER</description></item><item><title>LinuxShell快捷键</title><link>https://blog.linux88.com/post/OPS/LinuxShell%E5%BF%AB%E6%8D%B7%E9%94%AE/</link><pubDate>Tue, 10 Nov 2020 16:10:33 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/LinuxShell%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid><description>光标移动操作 ctrl + a：移动到最前面 ctrl + e：移动到最后面 ctrl + b：光标向前移动一格 ctrl + f：光标向后移动一格 删除操作 ctrl + q：删除所有内容 ctrl + u：删除所有内容并复制 ctrl + k：删除光标处到后面的所有内容 ctrl + w：删除</description></item><item><title>PicGo-Core 和 Typora</title><link>https://blog.linux88.com/post/OPS/PicGo-Core%E5%92%8CTypora/</link><pubDate>Tue, 10 Nov 2020 15:26:31 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/PicGo-Core%E5%92%8CTypora/</guid><description>系统：Ubuntu 20.04 LTS 一、PicGo-Core 1.1 安装npm 1 sudo apt install npm -y 1.2 切换npm的源 1 sudo npm install -g cnpm --registry=https://registry.npm.taobao.org 1.3 安装PicGo-Croe 1 sudo cnpm install picgo -g 1.4 生成配置文件 Imgur图床的配置方法 PicGo-Core通过</description></item><item><title>查找Remmina的密码</title><link>https://blog.linux88.com/post/OPS/%E6%9F%A5%E6%89%BERemmina%E7%9A%84%E5%AF%86%E7%A0%81/</link><pubDate>Tue, 10 Nov 2020 15:20:29 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/%E6%9F%A5%E6%89%BERemmina%E7%9A%84%E5%AF%86%E7%A0%81/</guid><description>Seshorse 可以管理 GNOME Keyring。 1 2 3 4 5 # 安装 sudo apt-get install seahorse # 运行 seahorse 查找远程管理工具 Remmina 密码的保存位置</description></item><item><title>LittleKnowledge</title><link>https://blog.linux88.com/post/Go/LittleKnowledge/</link><pubDate>Tue, 03 Nov 2020 01:45:17 +0800</pubDate><guid>https://blog.linux88.com/post/Go/LittleKnowledge/</guid><description>CGO_ENABLED动态链接 测试跳过 90000000打印为90,000,000 子context超时时间会覆上层的context超时 &amp;ndash;work flag打印位置 设置log日志格式 proto不删除字段, 而是保留 gRPC</description></item><item><title>精通Wire</title><link>https://blog.linux88.com/post/Go/%E7%B2%BE%E9%80%9AWire/</link><pubDate>Wed, 14 Oct 2020 20:25:05 +0800</pubDate><guid>https://blog.linux88.com/post/Go/%E7%B2%BE%E9%80%9AWire/</guid><description>wire是什么 ？ Wire是Go Cloud团队开发的Golang中的轻量级依赖注入工具。它会自动生成代码，然后在编译时注入依赖项。 依赖注入是保持软件“loose-coupling and easy to maintain（</description></item><item><title>使用Wire在GO中进行依赖注入</title><link>https://blog.linux88.com/post/Go/%E4%BD%BF%E7%94%A8Wire%E5%9C%A8GO%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</link><pubDate>Wed, 14 Oct 2020 20:21:26 +0800</pubDate><guid>https://blog.linux88.com/post/Go/%E4%BD%BF%E7%94%A8Wire%E5%9C%A8GO%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</guid><description>什么是依赖注入？ 依赖注入是您的组件（通常是go中的结构）在创建时应接收其依赖的想法。这与初始化期间构建其自身依赖关系的组件的关联反模式背道而驰。 依赖注入是保持软件“松耦合且易于维护”的最重要的设计原则</description></item><item><title>Golang的环境变量</title><link>https://blog.linux88.com/post/Go/Golang%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link><pubDate>Sat, 10 Oct 2020 18:01:22 +0800</pubDate><guid>https://blog.linux88.com/post/Go/Golang%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid><description>什么是环境变量 环境变量是系统级的键-值对，正在运行的进程可以访问它。这些通常用于使同一程序在不同的部署环境（例如PROD，DEV或TEST）中表现不同。在环境中存储配置是a twelve-factor app的原理之一。它使应用</description></item><item><title>UFW</title><link>https://blog.linux88.com/post/OPS/UFW/</link><pubDate>Sun, 04 Oct 2020 18:16:12 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/UFW/</guid><description>一、UFW介绍 下文引用自Wikipedia UFW全称为Uncomplicated Firewall[1]，是Ubuntu系统上默认的防火墙组件，为了轻量化配置iptables而开发的一款工具。UFW提供</description></item><item><title>RPC</title><link>https://blog.linux88.com/post/rpc/</link><pubDate>Mon, 10 Aug 2020 15:38:51 +0800</pubDate><guid>https://blog.linux88.com/post/rpc/</guid><description>一、RPC 机制 RPC是远程过程调用协议（Remote Procedure Call）。 RPC是指client上的进程，调用server上的进程，其中client上的调用被挂起，而server上的被调用进程开始执行，并将结</description></item><item><title>Goland</title><link>https://blog.linux88.com/post/IDE/goland/</link><pubDate>Wed, 15 Jul 2020 10:30:39 +0800</pubDate><guid>https://blog.linux88.com/post/IDE/goland/</guid><description>自动生成struct tag File-&amp;gt;Settings-&amp;gt;Live Templates</description></item><item><title>PHP环境</title><link>https://blog.linux88.com/post/PHP/PHP%E7%8E%AF%E5%A2%83/</link><pubDate>Thu, 28 May 2020 20:37:25 +0800</pubDate><guid>https://blog.linux88.com/post/PHP/PHP%E7%8E%AF%E5%A2%83/</guid><description>一、docker的php环境安装 本地部署docker环境的php 二、IDE设置 1 2 3 # 本地查看IED端口是否有监听 $ ss -tunlp |grep 9050 tcp LISTEN 0 50 *:9050 *:* users:((&amp;#34;java&amp;#34;,pid=224295,fd=119)) 三、游览器下载插件 下载 Xdebug helper 插件 Xdebug+PhpStorm 远程调试</description></item><item><title>Git常用操作</title><link>https://blog.linux88.com/post/OPS/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link><pubDate>Sun, 10 May 2020 16:21:40 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid><description>子模块 1 2 3 4 5 # 添加git的子模块 git submodule add https://github.com/koirand/pulp.git themes/pulp # 更新子模块 git submodule update --remote --rebase 删除分支 1 2 3 4 5 6 7 8 # 查看分支 git branch -a # 删除远程分支 git push origin --delete BRANCH_NAME # 删除本地分支 git branch -d BRANCH_NAME git diff 1 2 3 4 5 6 7 8 # 工作区与暂存区 git diff FILE_NAME # 暂</description></item><item><title>dlv</title><link>https://blog.linux88.com/post/Go/dlv/</link><pubDate>Wed, 01 Apr 2020 15:13:52 +0800</pubDate><guid>https://blog.linux88.com/post/Go/dlv/</guid><description>远程调试并使用配置文件 1 2 3 4 5 # 使用Go 1.10或更高版本编译应用程序： go build -gcflags \&amp;#34;all=-N -l\&amp;#34; github.com/app/demo # 然后使用以下命令通过Delve运行它： dlv --listen=:9345 --headless=true --api-version=2 --accept-multiclient exec ./demo -- -config=../config/config.xml delve</description></item><item><title>设计模式--状态模式</title><link>https://blog.linux88.com/post/DesignPatterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B/18%E7%8A%B6%E6%80%81/</link><pubDate>Fri, 13 Mar 2020 20:25:05 +0800</pubDate><guid>https://blog.linux88.com/post/DesignPatterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B/18%E7%8A%B6%E6%80%81/</guid><description>状态模式的概念 有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Tra</description></item><item><title>设计模式--观察者模式</title><link>https://blog.linux88.com/post/DesignPatterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B/13%E8%A7%82%E5%AF%9F%E8%80%85/</link><pubDate>Fri, 13 Mar 2020 20:25:05 +0800</pubDate><guid>https://blog.linux88.com/post/DesignPatterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B/13%E8%A7%82%E5%AF%9F%E8%80%85/</guid><description>观察者模式的概念 什么是观察者模式 在对象间定义一种一对多的依赖关系，当这个对象状态发生改变时，所有依赖它的对象都会被通知并自动更新。 Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically. /' OBSERVER '/ @startuml interface Subject { + attach(in o : Observer) + detach(in o</description></item><item><title>设计模式--享元模式</title><link>https://blog.linux88.com/post/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B/12%E4%BA%AB%E5%85%83/</link><pubDate>Thu, 12 Mar 2020 20:25:05 +0800</pubDate><guid>https://blog.linux88.com/post/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B/12%E4%BA%AB%E5%85%83/</guid><description>享元模式的概念 什么是享元模式 使用共享对象可有效地支持大量的细粒度的对象。指享元模式要求能够共享的对象必须是轻量级对象，也就是细粒度对象，因此享元模式又称为轻量级模式。 Use sharing to support large numbers of fine-grained objects efficiently. 内部状态 (Intrinsic St</description></item><item><title>设计模式--外观模式</title><link>https://blog.linux88.com/post/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B/10%E5%A4%96%E8%A7%82/</link><pubDate>Tue, 10 Mar 2020 20:25:05 +0800</pubDate><guid>https://blog.linux88.com/post/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B/10%E5%A4%96%E8%A7%82/</guid><description>外观模式的概念 什么是外观模式 门面模式（Facade Pattern）也叫做外观模式，是一种比较常用的封装模式，其定义如下：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高</description></item><item><title>设计模式--适配器模式</title><link>https://blog.linux88.com/post/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B/09%E9%80%82%E9%85%8D%E5%99%A8/</link><pubDate>Mon, 09 Mar 2020 20:25:05 +0800</pubDate><guid>https://blog.linux88.com/post/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B/09%E9%80%82%E9%85%8D%E5%99%A8/</guid><description>适配器模式的概念 什么是适配器模式 将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。 适配模式的作用： 接口转换，将原有的接口（或方法）转换成另一种接口</description></item><item><title>设计模式--装饰器模式</title><link>https://blog.linux88.com/post/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B/08%E8%A3%85%E9%A5%B0%E5%99%A8/</link><pubDate>Sun, 08 Mar 2020 20:25:05 +0800</pubDate><guid>https://blog.linux88.com/post/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B/08%E8%A3%85%E9%A5%B0%E5%99%A8/</guid><description>装饰器模式的概念 什么是装饰器模式 动态地给一个对象增加一些额外的职责，就拓展对象功能来说，装饰模式比生成子类的方式更为灵活。 Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. /' DECORATOR '/ @startuml interface Component { + operation() } class ConcreteComponent { + operation() } interface Decorator { component Component +</description></item><item><title>设计模式--桥接模式</title><link>https://blog.linux88.com/post/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B/07%E6%A1%A5%E6%8E%A5/</link><pubDate>Sat, 07 Mar 2020 20:25:05 +0800</pubDate><guid>https://blog.linux88.com/post/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B/07%E6%A1%A5%E6%8E%A5/</guid><description>桥接模式的概念 什么是桥接模式 桥接模式被定义为：“将抽象和实现解耦，让它们可以独立变化。”在其他资料和书籍中，还有另外一种更加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式</description></item><item><title>设计模式--代理模式</title><link>https://blog.linux88.com/post/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B/06%E4%BB%A3%E7%90%86/</link><pubDate>Fri, 06 Mar 2020 20:25:05 +0800</pubDate><guid>https://blog.linux88.com/post/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B/06%E4%BB%A3%E7%90%86/</guid><description>代理模式的概念 什么是代理模式 为其他对象提供一种代理以控制对这个对象的访问。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。 Provide a surrogate or placeholder for another object to control access to it. /' PROXY '/ @startuml class Client interface Subject { +</description></item><item><title>设计模式--原型模式</title><link>https://blog.linux88.com/post/DesignPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/05%E5%8E%9F%E5%9E%8B/</link><pubDate>Thu, 05 Mar 2020 20:25:05 +0800</pubDate><guid>https://blog.linux88.com/post/DesignPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/05%E5%8E%9F%E5%9E%8B/</guid><description>原型模式的概念 什么是原型模式 用原型实例指定要创建对象的种类，并通过拷贝这些原型的属性来创建新的对象。 Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype. /' PROTOTYPE '/ @startuml interface Prototype { + clone() } class Client class ConcretePrototype1 { + clone() } class ConcretePrototype2 { + clone() } hide empty members Client --&amp;gt; Prototype Prototype &amp;lt;|--</description></item><item><title>设计模式--建造者</title><link>https://blog.linux88.com/post/DesignPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/04%E5%BB%BA%E9%80%A0%E8%80%85/</link><pubDate>Wed, 04 Mar 2020 20:25:05 +0800</pubDate><guid>https://blog.linux88.com/post/DesignPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/04%E5%BB%BA%E9%80%A0%E8%80%85/</guid><description>建造者的概念 什么是建造者模式 将一复杂对象的构建过程和它的表现分离，使得同样的构建过程可以获取（创建）不同的表现。 Separate the construction of a complex object from its representation so that the same construction process can create different representation. /' BUILDER '/ @startuml class Director { + construct() } interface Builder { buildPart() } class ConcreteBuilder { + buildPart() + getResult() } class</description></item><item><title>Python环境</title><link>https://blog.linux88.com/post/Python/Python%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 28 Dec 2019 20:37:25 +0800</pubDate><guid>https://blog.linux88.com/post/Python/Python%E7%8E%AF%E5%A2%83/</guid><description>一、pyenv 1.1 pyenv 基于 Github Checkout 安装 git clone pyenv的代码 1 git clone https://github.com/pyenv/pyenv.git ~/.pyenv 定义环境变量PYENV_ROOT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # For bash: echo &amp;#39;export PYENV_ROOT=&amp;#34;$HOME/.pyenv&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile echo &amp;#39;export PATH=&amp;#34;$PYENV_ROOT/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile # For Ubuntu Desktop: echo &amp;#39;export PYENV_ROOT=&amp;#34;$HOME/.pyenv&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bashrc echo &amp;#39;export PATH=&amp;#34;$PYENV_ROOT/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bashrc # For Zsh: echo &amp;#39;export PYENV_ROOT=&amp;#34;$HOME/.pyenv&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc echo &amp;#39;export PATH=&amp;#34;$PYENV_ROOT/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt;</description></item><item><title>gRPC</title><link>https://blog.linux88.com/post/Go/gRPC/</link><pubDate>Tue, 17 Dec 2019 10:48:05 +0800</pubDate><guid>https://blog.linux88.com/post/Go/gRPC/</guid><description>gRPC是可以在任何环境中运行的现代开源高性能RPC框架。 它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，健康检查和身份验证。 它也适用于分布式计算的最后一英里，以</description></item><item><title>Go JSON</title><link>https://blog.linux88.com/post/Go/json/</link><pubDate>Tue, 10 Dec 2019 11:44:48 +0800</pubDate><guid>https://blog.linux88.com/post/Go/json/</guid><description>结构体 field 大小写对序列化的影响 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) type ColorGroup struct {s ID int Name string Colors []string } func main() { m := []*ColorGroup{{ ID: 1, Name: &amp;#34;a&amp;#34;, Colors: nil, }, { ID: 2, Name: &amp;#34;a&amp;#34;, Colors: nil, }} b, err := json.Marshal(m) if err != nil { fmt.Println(&amp;#34;error:&amp;#34;, err) } os.Stdout.Write(b) } //output</description></item><item><title>Docker和docker Compose的安装与配置</title><link>https://blog.linux88.com/post/OPS/Docker%E5%92%8Cdocker-compose%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 03 Nov 2019 19:34:51 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/Docker%E5%92%8Cdocker-compose%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid><description>一、安装 1.1 安装docker 安装前准备 1 2 3 4 5 6 # 关闭selinux, 一定要重启 sed -i &amp;#39;s#SELINUX=enforcing#SELINUX=disabled#g&amp;#39; /etc/selinux/config # CentOS7修改docker源 sudo yum install -y yum-utils sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 根据不同的系统版本安装 Docker Engine 1.2 安装docekr-compose</description></item><item><title>在Golang中实现基于JWT的身份验证</title><link>https://blog.linux88.com/post/Go/JWT/</link><pubDate>Sun, 13 Oct 2019 19:53:26 +0800</pubDate><guid>https://blog.linux88.com/post/Go/JWT/</guid><description>本文翻译自《Implementing JWT based authentication in Golang》。全文如下： 认证是让您的应用程序知道向您的应用程序发送的请求一定是请求人发送的。JSON网络令牌(JWT)是一种允许认证的方法，它不需要在系统</description></item><item><title>Rsync</title><link>https://blog.linux88.com/post/OPS/rsync/</link><pubDate>Thu, 03 Oct 2019 10:20:50 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/rsync/</guid><description>一、基本配置 Server端配置 安装rsync 1 yum install -y rsync 配置rsync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # cat /etc/rsyncd.conf # /etc/rsyncd: configuration file for rsync daemon mode # See rsyncd.conf man page for more options. # configuration example: # uid =</description></item><item><title>SVN</title><link>https://blog.linux88.com/post/OPS/svn/</link><pubDate>Sat, 24 Nov 2018 18:26:07 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/svn/</guid><description>回退到某个版本 1 2 3 4 5 # 从修订版150（当前）回到修订版140 svn update svn log -l 5 svn merge -r 150:140 . svn commit -m &amp;#34;Rolled back to r140&amp;#34;</description></item><item><title>Linux Commands</title><link>https://blog.linux88.com/post/OPS/LinuxCommand/</link><pubDate>Mon, 06 Nov 2017 10:57:38 +0800</pubDate><guid>https://blog.linux88.com/post/OPS/LinuxCommand/</guid><description>查找替换多个文件 1 grep -rl &amp;#34;old_string&amp;#34; . | xargs sed -i &amp;#39;s/old_string/new_string/g&amp;#39; grep -rl: 递归搜索，仅打印包含“ old_string”的文件 xargs: 接受grep命令的输出，并使其成为下一个命令（即sed命令）的输入 sed -i ‘s/old_string/new_s</description></item><item><title>归档</title><link>https://blog.linux88.com/archives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.linux88.com/archives/</guid><description/></item><item><title>搜索</title><link>https://blog.linux88.com/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.linux88.com/search/</guid><description/></item></channel></rss>