<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Kira's blog</title><link>https://linux88.com/categories/Go/</link><description>Recent content in Go on Kira's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 11 Dec 2021 19:50:31 +0800</lastBuildDate><atom:link href="https://linux88.com/categories/Go/index.xml" rel="self" type="application/rss+xml"/><item><title>Safer Enums in Go</title><link>https://linux88.com/post/Go/safer-enums-in-go/</link><pubDate>Sat, 11 Dec 2021 19:50:31 +0800</pubDate><guid>https://linux88.com/post/Go/safer-enums-in-go/</guid><description>此文为 Safer Enums in Go 译文 枚举是 Web 应用程序的重要组成部分。Go 并没有开箱即用地支持它们，但有一些方法可以模拟它们。 许多显而易见的解决方案远非理想。以下是我们使用的一些想法，它们通过设计使枚举更安全。 iota Go 中可以</description></item><item><title>Testing With Gomock</title><link>https://linux88.com/post/Go/testing-with-gomock/</link><pubDate>Wed, 01 Sep 2021 14:44:15 +0800</pubDate><guid>https://linux88.com/post/Go/testing-with-gomock/</guid><description/></item><item><title>Contexts and structs</title><link>https://linux88.com/post/Go/Contexts-and-structs/</link><pubDate>Sun, 11 Jul 2021 21:14:41 +0800</pubDate><guid>https://linux88.com/post/Go/Contexts-and-structs/</guid><description>此文为 Contexts and structs 译文 介绍 在许多Go API中，尤其是现代的API，函数和方法的第一个参数往往是context.Context。Context 提供了一种跨API边界和进程之间传输超时、取消和传递元数据信息。当</description></item><item><title>Garbage Collection Semantics</title><link>https://linux88.com/post/Go/Garbage-Collection-Semantics/</link><pubDate>Mon, 07 Jun 2021 18:15:52 +0800</pubDate><guid>https://linux88.com/post/Go/Garbage-Collection-Semantics/</guid><description>从1.12版本开始，go使用了一个非生成的、并发的、三色的、标记和清扫的收集器 Mark Setup 当一个垃圾收集开始时，必须执行的第一个活动是打开写屏障。 为了打开写屏障，每一个正在运行的应用程序的程序都必须停止。 在垃</description></item><item><title>Unsafe</title><link>https://linux88.com/post/Go/unsafe/</link><pubDate>Wed, 31 Mar 2021 14:42:09 +0800</pubDate><guid>https://linux88.com/post/Go/unsafe/</guid><description>Type-Unsafe Pointers 深度解密Go语言之unsafe</description></item><item><title>使用Viper访问嵌套配置</title><link>https://linux88.com/post/Go/viper/</link><pubDate>Sun, 28 Mar 2021 10:56:06 +0800</pubDate><guid>https://linux88.com/post/Go/viper/</guid><description>本文翻译自《Accessing Nested Config with Viper》。全文如下： 我在写一个Go程序，它把其他一些东西粘在一起，所以它有一大堆基本上不相干的配置，被倾倒在一个yaml文件中。我对Viper的这种非标准使用有</description></item><item><title>如何在Go中处理JSON数据</title><link>https://linux88.com/post/Go/%E5%A6%82%E4%BD%95%E5%9C%A8Go%E4%B8%AD%E5%A4%84%E7%90%86JSON%E6%95%B0%E6%8D%AE/</link><pubDate>Thu, 25 Mar 2021 12:04:45 +0800</pubDate><guid>https://linux88.com/post/Go/%E5%A6%82%E4%BD%95%E5%9C%A8Go%E4%B8%AD%E5%A4%84%E7%90%86JSON%E6%95%B0%E6%8D%AE/</guid><description>Tutorial: How to work with JSON data in Go You might not be using json.Decoder correctly in golang</description></item><item><title>Goroutine并发控制</title><link>https://linux88.com/post/Go/goroutine%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link><pubDate>Fri, 15 Jan 2021 20:57:51 +0800</pubDate><guid>https://linux88.com/post/Go/goroutine%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid><description>此文为 Optimization for Number of goroutines Using Feedback Control 译文 Concurrency and complexity Concurrency and Go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { var wg sync.WaitGroup sem := make(chan struct{}, 3) for i := 0; i &amp;lt; 10; i++ { wg.Add(1) sem &amp;lt;- struct{}{} go func() { defer wg.DonOptimization for Number of goroutines Using Feedback Controle() defer func() { &amp;lt;-sem }() task() }() } wg.Wait() close(sem) } 1 Concurrency and application 为了实现速度和稳定性，并发数</description></item><item><title>Go Build Flags</title><link>https://linux88.com/post/Go/flags/</link><pubDate>Wed, 13 Jan 2021 15:13:52 +0800</pubDate><guid>https://linux88.com/post/Go/flags/</guid><description>在构建时设置一个环境变量 一个非常方便的构建标志，允许你在构建时从命令行设置一个变量。看下面的例子。 1 2 3 4 5 6 7 8 9 10 11 package main import ( &amp;#34;fmt&amp;#34; ) var who string func main() { fmt.Printf(&amp;#34;Hello, %s\n&amp;#34;, who) } 使用默认值我们得到以下结果。 1 2 3 4 $ go run main.go Hello, 通</description></item><item><title>Slice Tricks</title><link>https://linux88.com/post/Go/slice%E6%80%A7%E8%83%BD/</link><pubDate>Tue, 12 Jan 2021 18:26:42 +0800</pubDate><guid>https://linux88.com/post/Go/slice%E6%80%A7%E8%83%BD/</guid><description>Slice Tricks Slice Tricks的图 Append 1 a = append(a, b...) Copy 1 2 3 4 5 6 b = make([]T, len(a)) copy(b, a) // 这两种方法往往比上面的方法慢一些，但如果复制后有更多的元素要附加到b上，效率会更高。 b = append([]T(nil), a...) b = append(a[:0:0], a...) Cut 1 a = append(a[:i], a[j:]...) Delete 1 2 3 a = append(a[:i], a[i+1:]...) // or a = a[:i+copy(a[i:],</description></item><item><title>LittleKnowledge</title><link>https://linux88.com/post/Go/LittleKnowledge/</link><pubDate>Tue, 03 Nov 2020 01:45:17 +0800</pubDate><guid>https://linux88.com/post/Go/LittleKnowledge/</guid><description>CGO_ENABLED动态链接 测试跳过 90000000打印为90,000,000 子context超时时间会覆上层的context超时 &amp;ndash;work flag打印位置 设置log日志格式 proto不删除字段, 而是保留 gRPC</description></item><item><title>精通Wire</title><link>https://linux88.com/post/Go/%E7%B2%BE%E9%80%9AWire/</link><pubDate>Wed, 14 Oct 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/Go/%E7%B2%BE%E9%80%9AWire/</guid><description>wire是什么 ？ Wire是Go Cloud团队开发的Golang中的轻量级依赖注入工具。它会自动生成代码，然后在编译时注入依赖项。 依赖注入是保持软件“loose-coupling and easy to maintain（</description></item><item><title>使用Wire在GO中进行依赖注入</title><link>https://linux88.com/post/Go/%E4%BD%BF%E7%94%A8Wire%E5%9C%A8GO%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</link><pubDate>Wed, 14 Oct 2020 20:21:26 +0800</pubDate><guid>https://linux88.com/post/Go/%E4%BD%BF%E7%94%A8Wire%E5%9C%A8GO%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</guid><description>什么是依赖注入？ 依赖注入是您的组件（通常是go中的结构）在创建时应接收其依赖的想法。这与初始化期间构建其自身依赖关系的组件的关联反模式背道而驰。 依赖注入是保持软件“松耦合且易于维护”的最重要的设计原则</description></item><item><title>Golang的环境变量</title><link>https://linux88.com/post/Go/Golang%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link><pubDate>Sat, 10 Oct 2020 18:01:22 +0800</pubDate><guid>https://linux88.com/post/Go/Golang%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid><description>什么是环境变量 环境变量是系统级的键-值对，正在运行的进程可以访问它。这些通常用于使同一程序在不同的部署环境（例如PROD，DEV或TEST）中表现不同。在环境中存储配置是a twelve-factor app的原理之一。它使应用</description></item><item><title>dlv</title><link>https://linux88.com/post/Go/dlv/</link><pubDate>Wed, 01 Apr 2020 15:13:52 +0800</pubDate><guid>https://linux88.com/post/Go/dlv/</guid><description>远程调试并使用配置文件 1 2 3 4 5 # 使用Go 1.10或更高版本编译应用程序： go build -gcflags \&amp;#34;all=-N -l\&amp;#34; github.com/app/demo # 然后使用以下命令通过Delve运行它： dlv --listen=:9345 --headless=true --api-version=2 --accept-multiclient exec ./demo -- -config=../config/config.xml delve</description></item><item><title>设计模式--状态模式</title><link>https://linux88.com/post/design-patterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B/18%E7%8A%B6%E6%80%81/</link><pubDate>Fri, 13 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B/18%E7%8A%B6%E6%80%81/</guid><description>状态模式的概念 有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Tra</description></item><item><title>设计模式--观察者模式</title><link>https://linux88.com/post/design-patterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B/13%E8%A7%82%E5%AF%9F%E8%80%85/</link><pubDate>Fri, 13 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B/13%E8%A7%82%E5%AF%9F%E8%80%85/</guid><description>观察者模式的概念 什么是观察者模式 在对象间定义一种一对多的依赖关系，当这个对象状态发生改变时，所有依赖它的对象都会被通知并自动更新。 Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically. /' OBSERVER '/ @startuml interface Subject { + attach(in o : Observer) + detach(in o</description></item><item><title>设计模式--享元模式</title><link>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/12%E4%BA%AB%E5%85%83/</link><pubDate>Thu, 12 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/12%E4%BA%AB%E5%85%83/</guid><description>享元模式的概念 什么是享元模式 使用共享对象可有效地支持大量的细粒度的对象。指享元模式要求能够共享的对象必须是轻量级对象，也就是细粒度对象，因此享元模式又称为轻量级模式。 Use sharing to support large numbers of fine-grained objects efficiently. 内部状态 (Intrinsic St</description></item><item><title>设计模式--外观模式</title><link>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/10%E5%A4%96%E8%A7%82/</link><pubDate>Tue, 10 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/10%E5%A4%96%E8%A7%82/</guid><description>外观模式的概念 什么是外观模式 门面模式（Facade Pattern）也叫做外观模式，是一种比较常用的封装模式，其定义如下：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高</description></item><item><title>设计模式--适配器模式</title><link>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/09%E9%80%82%E9%85%8D%E5%99%A8/</link><pubDate>Mon, 09 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/09%E9%80%82%E9%85%8D%E5%99%A8/</guid><description>适配器模式的概念 什么是适配器模式 将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。 适配模式的作用： 接口转换，将原有的接口（或方法）转换成另一种接口</description></item><item><title>设计模式--装饰器模式</title><link>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/08%E8%A3%85%E9%A5%B0%E5%99%A8/</link><pubDate>Sun, 08 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/08%E8%A3%85%E9%A5%B0%E5%99%A8/</guid><description>装饰器模式的概念 什么是装饰器模式 动态地给一个对象增加一些额外的职责，就拓展对象功能来说，装饰模式比生成子类的方式更为灵活。 Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. /' DECORATOR '/ @startuml interface Component { + operation() } class ConcreteComponent { + operation() } interface Decorator { component Component +</description></item><item><title>设计模式--桥接模式</title><link>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/07%E6%A1%A5%E6%8E%A5/</link><pubDate>Sat, 07 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/07%E6%A1%A5%E6%8E%A5/</guid><description>桥接模式的概念 什么是桥接模式 桥接模式被定义为：“将抽象和实现解耦，让它们可以独立变化。”在其他资料和书籍中，还有另外一种更加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式</description></item><item><title>设计模式--代理模式</title><link>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/06%E4%BB%A3%E7%90%86/</link><pubDate>Fri, 06 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/06%E4%BB%A3%E7%90%86/</guid><description>代理模式的概念 什么是代理模式 为其他对象提供一种代理以控制对这个对象的访问。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。 Provide a surrogate or placeholder for another object to control access to it. /' PROXY '/ @startuml class Client interface Subject { +</description></item><item><title>设计模式--原型模式</title><link>https://linux88.com/post/design-patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/05%E5%8E%9F%E5%9E%8B/</link><pubDate>Thu, 05 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/05%E5%8E%9F%E5%9E%8B/</guid><description>原型模式的概念 什么是原型模式 用原型实例指定要创建对象的种类，并通过拷贝这些原型的属性来创建新的对象。 Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype. /' PROTOTYPE '/ @startuml interface Prototype { + clone() } class Client class ConcretePrototype1 { + clone() } class ConcretePrototype2 { + clone() } hide empty members Client --&amp;gt; Prototype Prototype &amp;lt;|--</description></item><item><title>设计模式--建造者</title><link>https://linux88.com/post/design-patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/04%E5%BB%BA%E9%80%A0%E8%80%85/</link><pubDate>Wed, 04 Mar 2020 20:25:05 +0800</pubDate><guid>https://linux88.com/post/design-patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/04%E5%BB%BA%E9%80%A0%E8%80%85/</guid><description>建造者的概念 什么是建造者模式 将一复杂对象的构建过程和它的表现分离，使得同样的构建过程可以获取（创建）不同的表现。 Separate the construction of a complex object from its representation so that the same construction process can create different representation. /' BUILDER '/ @startuml class Director { + construct() } interface Builder { buildPart() } class ConcreteBuilder { + buildPart() + getResult() } class</description></item><item><title>gRPC</title><link>https://linux88.com/post/Go/gRPC/</link><pubDate>Tue, 17 Dec 2019 10:48:05 +0800</pubDate><guid>https://linux88.com/post/Go/gRPC/</guid><description>gRPC是可以在任何环境中运行的现代开源高性能RPC框架。 它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，健康检查和身份验证。 它也适用于分布式计算的最后一英里，以</description></item><item><title>Go JSON</title><link>https://linux88.com/post/Go/json/</link><pubDate>Tue, 10 Dec 2019 11:44:48 +0800</pubDate><guid>https://linux88.com/post/Go/json/</guid><description>结构体 field 大小写对序列化的影响 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) type ColorGroup struct {s ID int Name string Colors []string } func main() { m := []*ColorGroup{{ ID: 1, Name: &amp;#34;a&amp;#34;, Colors: nil, }, { ID: 2, Name: &amp;#34;a&amp;#34;, Colors: nil, }} b, err := json.Marshal(m) if err != nil { fmt.Println(&amp;#34;error:&amp;#34;, err) } os.Stdout.Write(b) } //output</description></item><item><title>在Golang中实现基于JWT的身份验证</title><link>https://linux88.com/post/Go/JWT/</link><pubDate>Sun, 13 Oct 2019 19:53:26 +0800</pubDate><guid>https://linux88.com/post/Go/JWT/</guid><description>本文翻译自《Implementing JWT based authentication in Golang》。全文如下： 认证是让您的应用程序知道向您的应用程序发送的请求一定是请求人发送的。JSON网络令牌(JWT)是一种允许认证的方法，它不需要在系统</description></item></channel></rss>